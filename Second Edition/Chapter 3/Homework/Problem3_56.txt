Consider the following assembly code:
x at %ebp+8, n at %ebp+12

1 movl 	     8(%ebp), %esi -- %esi = x
2 movl 	     12(%ebp), %ebx -- %ebx = n
3 movl 	     $-1, %edi -- %edi = -1
4 movl 	     $1, %edx  -- %edx = 1
5 .L2:
6 movl	     %edx, %eax -- %eax = 1
7 andl 	     %esi, %eax -- %eax = 1 & x
8 xorl 	     %eax, %edi -- %edi = - 1 ^ (1 & x)
9 movl 	     %ebx, %ecx -- %ecx = n
10 sall      %cl, %edx -- %edx = 1 << %cl (byte)
11 testl     %edx, %edx -- Compare %edx with itself
12 jne 	     .L2  -- continue loop if %edx < 0
13 movl      %edi, %eax -- %eax = %edi


The preceding code was generated by compiling C code that had the following
overall form:

1 int loop(int x, int n)
2 {
3 int result = -1 ;
4 int mask;
5 for (mask = 1; mask != 0 ; mask = mask << (n & FF) ) {
6 result ^= (1 & x);
7 }
8 return result;
9 }


Your task is to fill in the missing parts of the C code to get a program
equivalent to the generated assembly code. Recall that the result of the
function is returned in register %eax. You will find it helpful to examine
the assembly code before, during, and after the loop to form a consistent
mapping between the registers and the program variables.


A. Which registers hold program values x, n, result, and mask?
x = %esi
n = %ebx
result = %edi
mask = %edx

B. What are the initial values of result and mask?
result = 1
mask = 1

C. What is the test condition for mask? mask != 0 

D. How does mask get updated? mask is left shifted by the last byte of n

E. How does result get updated? result is updated by xoring result with 1 & x.

F. Fill in all the missing parts of the C code.
