The following code sequence occurs right near the beginning of
the assembly code generated by GCC for a C procedure:

 1    subl     %12, %esp
 2    movl     %ebx, (%esp)
 3    movl     %esi, 4(%esp)
 4    movl     %edi, 8(%esp)
 5    movl     8(%ebp), %ebx
 6    movl     12(%ebp), %edi
 7    movl     (%ebx), %esi
 8    movl     (%edi), %eax
 9    movl     16(%ebp), %eax
10    movl     (%edx), %ecx


We see that just three registers (%ebx, %esi, and %edi) are
saved on the stack (lines 2 - 4). The program modifies these and
three other registers (%eax, %ecx, and %edx). At the end of the
procedure, the values of registers %edi, %esi, and %ebx are
restored (not shown), while the other three are left in their
modified states.

Explain this apparent inconsistency in the saving and restoring
of register states.

Would this not be because the contents of those registers are
stored in the current frame?(These contents are caller-save
instead of calle-save, which are %ebx, %esi, %edi, which
must be restored.)
-----------------------------------------------------------------------
-----------------------------------------------------------------------
The problem makes concrete the discussion of register usage
conventions. Registers %edi, %esi, and %ebx are callee-save.
The procedure must save them on the stack before altering their
values and restore them before returning. The other three
registers are caller-save. They can be altered without affecting
the behavior of the caller.
-----------------------------------------------------------------------
-----------------------------------------------------------------------
